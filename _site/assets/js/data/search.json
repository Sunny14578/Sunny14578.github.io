[
  
  {
    "title": "linux - logrotate.d를 이용한 로그파일 관리 ",
    "url": "/posts/blog7/",
    "categories": "linux",
    "tags": "linux, log",
    "date": "2024-07-23 13:00:00 +0900",
    





    
    "snippet": "서버를 운영하면서 로그가 계속 쌓여 디스크 용량이 꽉차게 되어 서비스가 중단되는 경험을 하게 되어로그를 주기적으로 관리해주는 logrotate에 대해서 알아보도록 하겠습니다.logrotate리눅스 시스템에서 로그 파일을 자동으로 관리하는 도구이며. 로그 파일이 무한히 커지는 것을 방지하고, 디스크 공간을 효율적으로 사용할 수 있도록 돕습니다.주요기능 ...",
    "content": "서버를 운영하면서 로그가 계속 쌓여 디스크 용량이 꽉차게 되어 서비스가 중단되는 경험을 하게 되어로그를 주기적으로 관리해주는 logrotate에 대해서 알아보도록 하겠습니다.logrotate리눅스 시스템에서 로그 파일을 자동으로 관리하는 도구이며. 로그 파일이 무한히 커지는 것을 방지하고, 디스크 공간을 효율적으로 사용할 수 있도록 돕습니다.주요기능  로그 회전 : 일정 주기마다 새로운 로그 파일을 생성하고, 오래된 로그 파일을 보관  압축 : 회전된 로그 파일을 압축하여 디스크 공간을 절약  삭제 : 일정 기간이 지난 로그 파일을 자동으로 삭제  스크립트 실행 : 로그 회전 후 특정 명령이나 스크립트 실행  여기서 회전의 의미는 새로운 파일을 생성하다라는 의미설정하기logrotate를 설정하기 위해 /etc/logrotate.d/ 경로에 파일을 생성한뒤 밑의 코드를 작성해준다./var/log/*.log {    daily    rotate 1    compress    missingok    notifempty    delaycompress    postrotate        systemctl reload syslog &gt; /dev/null 2&gt;&amp;1 || true    endscript}코드 설명/var/log/*.log : /var/log 디렉토리의 모든 .log 파일을 대상으로 설정합니다.daily : 로그 파일을 매일 회전시킵니다. 즉, 새로운 로그 파일을 매일 생성합니다.rotate 1 : 최대 1개의 로그 파일만 보관합니다. 새로운 로그 파일이 생성되면 이전 로그 파일이 삭제됩니다.compress : 회전된 로그 파일을 압축하여 디스크 공간을 절약합니다.missingok : 로그 파일이 없더라도 오류를 발생시키지 않습니다. 로그 파일이 없는 경우 이를 무시합니다.notifempty : 로그 파일이 비어 있으면 회전시키지 않습니다. 비어 있는 파일은 회전하지 않습니다.delaycompress : 로그 파일을 회전시키고 다음 회전 주기까지 압축을 지연시킵니다. 즉, 회전된 다음 날에 압축됩니다.postrotate/endscript : 로그 파일이 회전된 후 실행할 명령어 블록입니다. 여기서는 systemctl reload syslog 명령어를 사용하여 syslog 서비스를 재시작합니다. &gt; /dev/null 2&gt;&amp;1는 명령어의 출력을 무시하고, || true는 명령어가 실패하더라도 무시합니다.  실행되는 시간은 sudo nano /etc/crontab 를 통해 확인해 볼 수 있다.25 6    * * *   root    test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.daily )분: 25분 시: 6시 (오전 6시 25분) 일: 매일 ( * ) 월: 매월 ( * ) 요일: 매주 ( * )"
  },
  
  {
    "title": "CS - BCP (Business Continuity Planning)",
    "url": "/posts/blog9/",
    "categories": "CS ( Computer Science )",
    "tags": "정보처리기사, BCP",
    "date": "2024-07-22 13:00:00 +0900",
    





    
    "snippet": "비즈니스 연속성 계획 관련 용어 정리BCP ( Business Continuity Planning )재난 및 재해 상황을 대비하여 기업의 비즈니스 연속성을 유지하기 위한 업무 복구에 대한 계획BIA(Business Impact Analysis)  장애나 재해로 인해 운영상의 주요 손실을 볼 것을 가정하여 시간 흐름에 따른 영향도 및 손실 평가를 조사하...",
    "content": "비즈니스 연속성 계획 관련 용어 정리BCP ( Business Continuity Planning )재난 및 재해 상황을 대비하여 기업의 비즈니스 연속성을 유지하기 위한 업무 복구에 대한 계획BIA(Business Impact Analysis)  장애나 재해로 인해 운영상의 주요 손실을 볼 것을 가정하여 시간 흐름에 따른 영향도 및 손실 평가를 조사하는 BCP를 구축하기 위한 비즈니스 영향 분석RTO(Recovery Time Objective)  업무 중단 시점부터 업무가 복구 되어 다시 가동 될 때까지의 시간. 재해 시 복구 목표 시간의 선정RPO(Recovery Point Objective)  업무 중단 시점부터 데이터가 복구되어 다시 정상가동될 때 데이터의 손실 허용 시점. 재해 시 복구 목표 지점의 선정DRP(Disaster Recovery Plan)  재난으로 장기간에 걸쳐 시설의 운영이 불가능한 경우를 대비한 재난 복구 계획DRS(Disaster Recovery System)  재해복구계획의 원활한 수행을 지원하기 위하여 평상시에 확보하여 두는 인적, 물적자원 및 이들에 대한 지속적인 관리체계가 통합된 재해복구센터Warm Site  재해복구센터에 주 센터와 동일한 수준의 자원을 보유하는 대신 중요성이 높은 자원만 부분적으로 재해복구센터에 보유하고 있는 방식으로 재해 발생 시 복구까지의 소요 시간은 수일 ~ 수주가 걸린다."
  },
  
  {
    "title": "CS - 암호화 알고리즘",
    "url": "/posts/blog8/",
    "categories": "CS ( Computer Science )",
    "tags": "정보처리기사, 암호화",
    "date": "2024-07-22 13:00:00 +0900",
    





    
    "snippet": "암호화 알고리즘 종류대칭키 암호화대칭키 암호화에서는 동일한 키가 암호화와 복호화에 사용됩니다. 빠르고 효율적이지만, 키의 안전한 분배와 관리가 중요합니다.DES (Data Encryption Standard)  미국 연방 표준국(NIST)에서 발표한 대칭키 기반의 블록 암호화방식 ( 64bit )  과거에 널리 사용되었으나 현재는 보안성이 낮아 많이 ...",
    "content": "암호화 알고리즘 종류대칭키 암호화대칭키 암호화에서는 동일한 키가 암호화와 복호화에 사용됩니다. 빠르고 효율적이지만, 키의 안전한 분배와 관리가 중요합니다.DES (Data Encryption Standard)  미국 연방 표준국(NIST)에서 발표한 대칭키 기반의 블록 암호화방식 ( 64bit )  과거에 널리 사용되었으나 현재는 보안성이 낮아 많이 사용되지 않는다.AES (Advanced Encryption Standard)  가장 널리 사용되는 대칭키 암호화 알고리즘 중 하나 DES에서 발전  128, 192, 256 비트키 지원  보안성과 성능이 뛰어나며, 미국 정부 표준으로 채택SEED  국내에서 개발한 블록 암호화 알고리즘 ( 128bit )  128bit 비밀키로부터 16개의 64비트 라운드 키가 생성ARIA(Academy, Research, Institute)  학계, 연구기관, 정부, 국정원과 산학연구협회가 발표한 블록암호화 알고리즘 ( 128bit )IDEA(international Data ENcryption Algorithm)  DES를 대체 하기 위해 스위스 연방기술 기관에서 개발한 블록암호화 알고리즘 ( 128 bit )비대칭키 암호화비대칭키 암호화에서는 공개키와 개인키라는 두 가지 키가 사용됩니다. 공개키로 데이터를 암호화하고 개인키로 이를 복호화합니다.이 방법은 키 분배 문제를 해결하지만, 대칭키 암호화보다 속도가 느립니다.디피-헬만 (Diffie-Hellman)  1976년에 고안된 최초의 공개키 알고리즘  이산대수의 계산이 어려운 문제를 기본원리로 함  두 사용자 간 공통의 암호화키를 안전하게 공유할 방법을 제시RSA (Rives Shamir Adleman)  1977년 3명의 MIT 수학 교수가 고안한 암호화 알고리즘  큰 인수의 곱을 소인수 분해하는 수학적 알고리즘 이용  주로 키 교환, 디지털 서명, 데이터 암호화에 사용ECC (Elliptic Cruve Cryptography)  1985에 코블리치와 밀러가 제안  RSA 암호화에 대한 대안, RSA보다 키의 비트 수를 적게 하면서 동일한 성능 제공  유한체 위에 정의된 타원곡선 군에서의 이산대수 문제에 기초DSA (Digital Signature Algorithm)  정부용 전자서명 알고리즘  안전성은 이산대수 문제 어려움에 기반Elgamal  공개키 알고리즘, RSA와 유사  이산대수의 계산이 어려운 문제를 기본원리로 함해시 암호화SHA 시리즈  1993년 미국 국가안보국이 설계, 미국 국립표준기술연구소에 의해 발표MD5(Message Digest algorithm 5)  1991년 R.Rivest가 MD4를 대체하기 위해 고안한 암호화 해시 함수  블록 크기는 512비트, 키 길이는 128비트N-NASH  1989년 일본의 전신전화주식회사(NTT)에서 발표한 암호화 해시 함수  블록 크기는 128비트, 키 길이는 128비트SNEFRU  1990년 R.C.Merkle가 발표한 해시 함수  32비트 프로세서에서 구현을 용이하게 할 목적으로 개발"
  },
  
  {
    "title": "CS - OSI 7계층 알아보기",
    "url": "/posts/blog6/",
    "categories": "CS ( Computer Science )",
    "tags": "정보처리기사, 네트워크",
    "date": "2024-07-22 13:00:00 +0900",
    





    
    "snippet": "출처 : IT 엔지니어를 위한 네트워크 입문OSI 7계층에 대해서 알아보기 위해 프로토콜의 개념을 익혀보자.프로토콜프로토콜은 규정이나 규약과 관련된 내용을 언급할 때 사용한다. 네트워크에서의 통신 규약도 프로토콜이라는 용어를 사용한다. 한정된 자원으로 통신을 수행해야 하다 보니 최대한 적은 데이터를 이용해 효율적인 프로토콜을 정의하고 사용해야 했다. ...",
    "content": "출처 : IT 엔지니어를 위한 네트워크 입문OSI 7계층에 대해서 알아보기 위해 프로토콜의 개념을 익혀보자.프로토콜프로토콜은 규정이나 규약과 관련된 내용을 언급할 때 사용한다. 네트워크에서의 통신 규약도 프로토콜이라는 용어를 사용한다. 한정된 자원으로 통신을 수행해야 하다 보니 최대한 적은 데이터를 이용해 효율적인 프로토콜을 정의하고 사용해야 했다.  기존에는 적은 컴퓨팅 자원과 매우 느린 네트워크 속도를 이용했기 때문에 효율을 위해 2진수 비트기반으로 만들어졌다.OSI 7계층과거에는 통신용 규약이 표준화되지 않았고 각 벤더에서 별도로 개발했기 때문에 호환되지 않는 시스템이나 애플리케이션이 많아서 통신이 불가능했다. 이를 하나로 규약으로 통합하려는 노력이 현재의 OSI 7계층으로 남아있다. 바로 이것이 네트워크의 주요 레퍼런스 모델로 활용되고 있지만 현재는 대부분의 프로토콜이 TCP/IP 프로토콜 스택 기반으로 되어있다.OSI 7계층은 다시 두 가지 계층으로 나눌 수 있다.  1~4계층 : 데이터 플로 계층 / 하위 계층  5~7계층 : 애플리케이션 계층 / 상위 계층계층 분류는 계층의 역할과 목표에 따른 것이다. 데이터 플로 계층은 데이터를 상대방에게 잘 전달하는 역할을 가지고있다. 애플리케이션 개발자는 애플리케이션 계층 프로토콜을 개발할 때 하위 데이터 플로계층을 고려하지 않고 데이터를 표현하는 데 초점을 맞춘다.  반면 네트워크 엔지니어는 이 부분에 대해서는 일반적으로 심각하게 고려하지 않는다. 이러한 이유로 애플리케이션 개발자는 하향식(Top-Down) 형식으로 네트워크를 바라보고 네트워크 엔지니어는 상향식(Bottom-Up) 형식으로 네트워크를 인식한다.피지컬 계층(Physical Layer)물리적 연결과 관련된 정보를 정의한다. 주로 전기 신호를 전달하는데 초점이 맞추어져 있다.  1계층의 주요 장비(허브, 리피터, 케이블, 커넥터, 트랜시버, 탭) 허브, 리피터는 네트워크 통신을 중재하는 네트워크 장비이다.  케이블과 커넥터는 케이블 본체를 구성하는 요소이고 트랜시버는 컴퓨터의 랜카드와 케이블을 연결하는 장비이다. 탭은 네트워크 모니터링과 패킷 분석을 위해 전기 신호를 다른 장비로 복제해 준다. 전기 신호가 1계층 장비에 들어오면 이 전기 신호를 재생성하여 내보낸다. 주소의 개념이 없기 때문에 전기 신호가 들어온 포트를 제외하고 모든 포트에 같은 전기 신호를 전송한다.데이터 링크 계층 (DataLink Layer)0전기 신호를 모아 우리가 알아볼 수 있는 데이터 형태로 처리한다. 출발지와 도착지 주소를 확인하고 내게 보낸 것이 맞는지, 또는 내가 처리해야 하는지에 대해 검사한 후 데이터 처리를 수행한다. 주소 체계가 생기면서 여러 통신이 한꺼번에 이루어지는 것을 구분하기 위한 기능이 주로 정의되어있다. 데이터에 대한 에러를 탐지 및 고치는 역할을 수행한다. 주소 체계가 생긴다는 것은 동시에 여려 명과 통신할 수 있다는 것이므로 받는 사람이 현재 데이터를 받을 수 있는지 확인하는 작업이 필요하다 이 것을 플로 컨트롤(Flow Control)이라고 한다.네트워크 계층 ( Network Layer)IP 주소와 같은 논리적인 주소가 정의된다. 데이터 통신을 할 때는 두가지 주소가 사용된다. 2계층의 물리적인 MAC 주소와 3계층의 논리적인 IP 주소이다. MAC 주소와 달리 IP 주소는 사용자가 환경에 맞게 변경해 사용할 수 있고 네트워크 주소 부분과 호스트 주소 부분으로 나뉜다. 3계층에서 동작하는 장비는 라우터이다. 라우터는 3계층에서 정의한 IP 주소를 이해할 수 있다. 라우터는 IP 주소를 사용해 최적의 경로를 찾아주고 해당 경로로 패킷을 전송하는 역할을 한다. 트랜스포트 계층 ( Transport Layer )하위 계층인 1, 2, 3계층은 신호와 데이터를 올바른 위치로 보내고 실제 신호를 잘 만들어 보내는 데 집중하였다면 4계층은 실제로 해당 데이터들이 정상적으로 잘 보내지도록 확인하는 역할을 한다.패킷 네트워크는 데이터를 분할해 패킷에 실어보내다 보니 중간에 패킷이 유실되거나 순서가 바뀌는 경우가 생길 수 있다. 이 문제를 해결하기 위해 패킷이 유실되거나 순서가 바뀌었을 때 바로잡아 주는 역할을 4계층에 담당한다.패킷을 분할할 때 패킷 헤더에 보내는 순서와 받는 순서를 적어 통신하여 바로 잡을 수 있다. 패킷에 보내는 순서를 명시한 것이 시퀀스 번호이고 받는 순서를 나타낸 것이 ACK 번호이다.4계층에서 동작하는 장비로는 로드 밸런서와 방화벽이 있다. 애플리케이션 구분자(포트 번호)와 시퀀스, ACK 번호 정보를 이용해 부하를 분산시키거나 보안 정책을 수립해 패킷을 통과, 차단하는 기능을 수행한다.세션 계층 ( Session Layer )양 끝단의 응용 프로세스가 연결을 성립하도록 도와주고 연결이 안정적으로 유지되도록 관리하고 작업이 완료 후에는 이 연결을 끊는 역할을 한다. “세션”을 관리하는 것이 주요 역할인 세션 계층은 TCP/IP 세션을 만들고 없애는 책임을 진다. 또한 에러로 중단된 토잇ㄴ에 대한 에러 복구와 재전송도 수행한다.프레젠테이션 계층 ( presentation Layer )시스템 간의 통신을 돕기 위해 하나의 통일된 구문 형식으로 변환시키는 기능을 수행한다. 일종의 번역기나 변환기 역할을 수행하는 계층이고 이런 기능은 사용자 시스템의 응용 계층에서 데이터의 형식상 차이를 다루는 부담을 덜어준다.  MIME 인코딩이나 암호화, 압축, 코드 변환과 같은 동작이 이 계층에서 이루어진다.애플리케이션 계층( apllication Layer )애플리케이션 프로세스를 정의하고 애플리케이션 서비스를 수행한다. 네트워크 소프트웨어의 UI 부분이나 사용자 입, 출력 부분을 정의하는 것이 애플리케이션 계층의 역할이다. 대표적인 프로토콜로는 FTP, SMTP, HTTP, TELNET이 있다."
  },
  
  {
    "title": "Java - LocalDateTime 자료형 다뤄보기",
    "url": "/posts/blog5/",
    "categories": "Java",
    "tags": "LocalDateTime, 날짜",
    "date": "2024-07-19 13:00:00 +0900",
    





    
    "snippet": "출처 docsLocalDateTime 자료형 이용해보기현재 시간 구하기LocalDateTime time = LocalDateTime.now();System.out.println(\"현재 날짜와 시간: \" + time);//현재 날짜와 시간: 2024-07-19T13:08:16.596698시간 만들기LocalDateTime dateTime = LocalD...",
    "content": "출처 docsLocalDateTime 자료형 이용해보기현재 시간 구하기LocalDateTime time = LocalDateTime.now();System.out.println(\"현재 날짜와 시간: \" + time);//현재 날짜와 시간: 2024-07-19T13:08:16.596698시간 만들기LocalDateTime dateTime = LocalDateTime.of(2024, 7, 19, 10, 30);System.out.println(\"설정한 날짜와 시간: \" + dateTime);//설정한 날짜와 시간: 2024-07-19T10:30시간 덧셈, 뺄샘LocalDateTime future = time.plusDays(10).plusHours(5);LocalDateTime past = time.minusMonths(2).minusMinutes(15);System.out.println(\"현재 날짜와 시간: \" + time);System.out.println(\"10일 5시간 후: \" + future);System.out.println(\"2개월 15분 전: \" + past);//현재 날짜와 시간: 2024-07-19T13:08:16.596698//10일 5시간 후: 2024-07-29T18:08:16.596698//2개월 15분 전: 2024-05-19T12:53:16.596698오늘의 시작 시간 / 끝 시간 구하기LocalDateTime startDay = time.with(LocalTime.MIN);LocalDateTime endtDay = time.with(LocalTime.MAX);System.out.println(\"오늘의 시작 시간: \" + startDay);System.out.println(\"오늘의 끝 시간: \" + endtDay);//오늘의 시작 시간: 2024-07-19T00:00//오늘의 끝 시간: 2024-07-19T23:59:59.999999999시작날짜 값과 끝 날짜 값을 받아서 활용할 때다음과 같은 날짜 input 태그를 사용하여 데이터를 가져오고 싶을 때&lt;input type=\"date\" id=\"startDate\"&gt;&lt;input type=\"date\" id=\"endDate\"&gt;일반적으로 데이터를 조회할때 시작날짜와 끝날짜를 클릭해서 조회하게 되는데17일과 19일을 클릭해서 조회할경우 17일 00시 부터의 데이터와 19일 23:59:59시 까지의 데이터를 가져와야한다. input 태그로 부터 가져온 날짜는 00시로 되어있기 때문에 끝 날짜를 수정해주지 않으면 17일 00시 ~ 19일 00시 범위가 되어버려서19일 데이터는 가져오지 못한다.  해결방법 : endDate의 시간을 23:59:59시로 변경해주는 작업이 필요하다.LocalDateTime startDate = LocalDateTime.of(2024, 7, 17, 0, 0); // 날짜 가데이터 생성LocalDateTime endDate = LocalDateTime.of(2024, 7, 19, 0, 0); endDate = endDate.with(LocalTime.MAX)System.out.println(\"시간 수정: \" + endtDay);//시간 수정: 2024-07-19T23:59:59.999999999"
  },
  
  {
    "title": "Github Blog 만들기 - Jekyll thema 커스텀 해보기",
    "url": "/posts/blog4/",
    "categories": "Github Blog",
    "tags": "jekyll",
    "date": "2024-07-16 15:30:00 +0900",
    





    
    "snippet": "사전지식 습득html file 들을 살펴보면 값들이 직접적으로 기입되어있는게 아닌 다른 경로에서 가져오는 형태로 작성되어져 있습니다. site.data.locales[include.lang].meta 이처럼 많은 부분이 site로 시작하는 코드를 확인해볼 수 있는데 이것의 의미를 알아보겠습니다.Jekyll 기본 동작 원리꼭 알아야 하는 것! _conf...",
    "content": "사전지식 습득html file 들을 살펴보면 값들이 직접적으로 기입되어있는게 아닌 다른 경로에서 가져오는 형태로 작성되어져 있습니다. site.data.locales[include.lang].meta 이처럼 많은 부분이 site로 시작하는 코드를 확인해볼 수 있는데 이것의 의미를 알아보겠습니다.Jekyll 기본 동작 원리꼭 알아야 하는 것! _config.yml 파일에서 설정된 내용은 site 객체에 로드됩니다. 해당 파일이 사이트의 전역 설정을 정의하게 됩니다.site.data는 _data 디렉토리에 있는 파일을 로드하고 파일의 확장자는 YAML, JSON, CSV와 같은 파일입니다. 그렇다면 site.data.locales[include.lang].meta 코드를 살펴보면 _data 폴더안 / locales 폴더안 / [include. lang]를 참조하게되는데 이것은 현재 선택된 언어 코드를 나타냅니다. 현재 선택된 언어 코드는 _config.yml file에서 맨위 부근의 코드에서 확인 가능합니다.# Import the themetheme: jekyll-theme-chirpy# The language of the webpage › http://www.lingoes.net/en/translator/langcode.htm# If it has the same name as one of the files in folder `_data/locales`, the layout language will also be changed,# otherwise, the layout language will use the default value of 'en'.lang: ko-KR저는 한국어를 적용하기 위해 ko-KR로 설정된 상태이고 최종적으로 site.data.locales 안에 있는 ko-KR.yml 파일을 참조하게 되고. ko-KR.yml file안의 meta 값을 가져오라는 의미가 되는겁니다.  Sidebar Image 변경하기_config.yml에서 avatar 항목에 본인이 넣고싶은 이미지 경로를 추가하면된다. assets/img에 이미지를 보관했다면 아래와 같은 형태로 작성해준다.avatar: \"assets/img/이미지명\"만약 다음과 같이 경로상에도 문제가 없는 상황인데 이미지를 찾지 못하는 상황이라면 avatar 항목 바로 위의cdn: \"https://chirpy-img.netlify.app\" 부분이 활성화 되어있으면 cdn 경로에서 이미지를 찾기 때문에 찾을 수 없는 것이다.해당 부분을 주석처리해주자. favicon 변경하기위 빨간네모박스안의 icon을 favicon이라고 부른다 이것을 바꾸는 방법에 대해 알아보자.먼저 내가 적용하고 싶은 icon 파일을 준비해야한다.favicon 생성사이트에 접속해서 이미지를 업로드하고 Download button을 누르면적용시킬 favicon icon들을 만들어준다.해당 파일들을 assets/img/favicons 폴더 안에 넣어주면 끝! Footer 변경footer는 _includes/footer.html 경로에서 변경할 수 있다. blog 맨아래의 Powered by 와 같은 문구를 지우려면site.data.locales[include.lang].meta | replace: ':PLATFORM', _platform | replace: ':THEME', _theme와 같은 코드가 ko-KR.yml file에 밑과 같이 정의되어 있다. 해당 부분을 주석처리 하면 나타나지 않을 것이다.meta: Powered by :PLATFORM with :THEME theme"
  },
  
  {
    "title": "Github Blog 만들기 - Google Analytics",
    "url": "/posts/blog3/",
    "categories": "Github Blog",
    "tags": "Google Analytics, Analytics",
    "date": "2024-07-16 11:30:00 +0900",
    





    
    "snippet": "jekyll theme에 Google Analytics 적용하기Google Analytics는 웹사이트와 앱 모두에서 이벤트 기반 데이터를 수집하는 차세대 애널리틱스 [GA4] 이용애널리틱스 계정 만들기구글 애널리틱스 페이지에서 구글 계정 로그인 후 계정 생성화면 중앙의 측정 시작 버튼 클릭계쩡 생성계정 이름 입력 후 다음버튼 클릭속성 만들기속성 이름...",
    "content": "jekyll theme에 Google Analytics 적용하기Google Analytics는 웹사이트와 앱 모두에서 이벤트 기반 데이터를 수집하는 차세대 애널리틱스 [GA4] 이용애널리틱스 계정 만들기구글 애널리틱스 페이지에서 구글 계정 로그인 후 계정 생성화면 중앙의 측정 시작 버튼 클릭계쩡 생성계정 이름 입력 후 다음버튼 클릭속성 만들기속성 이름 입력 / 보고 시간대 대한민국 입력 / 통화 대한민국 원비즈니스 세부정보비즈니스 세부정보 입력은 본인 프로젝트에 맞는 업종 및 규모 선택비즈니스 목표필자는 사용자 행동 검토만 체크하고 진행했다.데이터 수집 시작하기웹에서 진행할 것이기 때문에 웹을 선택했다.데이터 스트림 생성본인 웹사이트 URL 및 스트림 이름을 입력한다.스트림 까지 설정됐으면 웹 스트림정보 창에서 측정 ID 값을 복사한다.복사한 ID값은 _config.yml file에서 analytics tab의 google id에 넣어준다.# Web Analytics Settingsanalytics:  google:    id: 측정ID값여기까지 잘 설정했다면 애널리틱스 페이지에서 통계보고서를 확인할 수 있다.마치며_config.yml 에 적용된 측정 ID값은 _includes/js-selector.html 파일안에서 불러와서 사용되어진다."
  },
  
  {
    "title": "Github Blog 만들기 - Utterances 댓글 기능 추가",
    "url": "/posts/blog2/",
    "categories": "Github Blog",
    "tags": "Utterances, comments",
    "date": "2024-07-15 17:15:00 +0900",
    





    
    "snippet": "utterances 댓글기능 사용해보기utterances : Github의 이슈를 이용해 댓글로 표시하는 기능utterances.app 홈페이지에 접속하면 오른쪽에 install 탭이 있다. 버튼을 클릭하여 설치해준다.필자는 이미 설치되어있어 Configure로 표시설치 후에 github login 창이 뜬다면 login 후 진행댓글기능을 적용할 하나...",
    "content": "utterances 댓글기능 사용해보기utterances : Github의 이슈를 이용해 댓글로 표시하는 기능utterances.app 홈페이지에 접속하면 오른쪽에 install 탭이 있다. 버튼을 클릭하여 설치해준다.필자는 이미 설치되어있어 Configure로 표시설치 후에 github login 창이 뜬다면 login 후 진행댓글기능을 적용할 하나의 레파지토리에 적용하기 위해 select 해준다.정상적으로 설치가 됐다면 기존의 Utterances 페이지로 돌아온다.ConfigurationUtterances 페이지의 중간지점에 configuration tab에서 나의 레파지토리 주소를 입력해준다. 입력형식 저장소ID/저장소명  ex: sunny14578/sunny14578.github.ioEnable Utterances입력 후 페이지를 내리다 보면 Enable Utterances tab 에서 script code를 확인할 수 있다. 두번째 줄의 repo= 부분에 전에 입력한 값이 나와있다면 설정 끝html file에 적용하기위 스크립트를 복사한 후 필자와 같이 Jekyll thema를 이용한 구조에서는 _layouts/post.html 파일의 맨 밑에 넣어주면 된다.    &lt;!-- .post-tail-bottom --&gt;  &lt;/div&gt;  &lt;!-- div.post-tail-wrapper --&gt;  &lt;!-- Utterances 댓글 스니핏 삽입 --&gt;  &lt;script src=\"https://utteranc.es/client.js\"        repo=\"sunny14578/sunny14578.github.io\"        issue-term=\"pathname\"        theme=\"github-light\"        crossorigin=\"anonymous\"        async&gt;  &lt;/script&gt;테스트위 진행사항까지 문제없이 적용됐다면 포스팅 화면 맨아래에 아래와 같이 댓글을 적을 수 있는 탭이 적용됐을것이다.댓글을 적을 수 없다면 빨간박스 안의 버튼이 로그인 버튼으로 활성화 되어있을 것이다.  로그인 후 사용가능!댓글을 추가했다면 utterances를 적용시킨 레파지토리 issues에 저장된다.내가 겪은 문제댓글을 적었으나 저장되지 않는 현상 필자는 fork 해와서 블로그를 적용했는데 이 때 issues tab이 생성되지 않는 경우가 있다. issues tab을 생성해주기 위해 해당 레파지토리의 setting 탭에서 Features의 Issues 체크박스를 활성화 해준다."
  },
  
  {
    "title": "Local에서 LLM 모델 사용해보기 ( 무료!! )",
    "url": "/posts/blog1/",
    "categories": "LangChain",
    "tags": "LLM, LangChain",
    "date": "2024-07-12 00:40:00 +0900",
    





    
    "snippet": "출처 : 테디노트LangServe를 이용해 로컬에서 LLM 모델 사용해보기설치올라마(Ollama)올라마 Link 에서 중앙에 있는 다운로드 버튼으로 별도의 설정없이 진행HugginFace Hub 설치pip install hugginface-hubEEVE(야놀자) modelHugginFace Page 페이지에서 EEVE-Korean-Instruct-10...",
    "content": "출처 : 테디노트LangServe를 이용해 로컬에서 LLM 모델 사용해보기설치올라마(Ollama)올라마 Link 에서 중앙에 있는 다운로드 버튼으로 별도의 설정없이 진행HugginFace Hub 설치pip install hugginface-hubEEVE(야놀자) modelHugginFace Page 페이지에서 EEVE-Korean-Instruct-10.8B-v1.0-Q8_0.gguf모델을 다운로드 받아주자"
  }
  
]

